<!DOCTYPE html>
<html>
  <head>
    <title></title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

    <style type="text/css">
      @import url(http://fonts.googleapis.com/css?family=Droid+Serif);
      @import url(http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body {
        font-family: 'Droid Serif';
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
      }
      .remark-slide-content h1 { font-size: 3em; }
      .remark-slide-content h2 { font-size: 2em; }
      .remark-slide-content h3 { font-size: 1.6em; }
      .footnote {
        position: absolute;
        bottom: 3em;
      }
      li p { line-height: 1.25em; }
      .red { color: #fa0000; }
      .large { font-size: 2em; }
      a, a > code {
        color: rgb(249, 38, 114);
        text-decoration: none;
      }
      code {
        -moz-border-radius: 5px;
        -web-border-radius: 5px;
        background: #e7e8e2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .pull-right ~ p {
        clear: both;
      }
      #slideshow .slide .content code {
        font-size: 0.8em;
      }
      #slideshow .slide .content pre code {
        font-size: 0.9em;
        padding: 15px;
      }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      /* Slide-specific styling */
      #slide-inverse .footnote {
        bottom: 12px;
        left: 20px;
      }
      #slide-how .slides {
        font-size: 0.9em;
        position: absolute;
        top:  151px;
        right: 140px;
      }
      #slide-how .slides h3 {
        margin-top: 0.2em;
      }
      #slide-how .slides .first, #slide-how .slides .second {
        padding: 1px 20px;
        height: 90px;
        width: 120px;
        -moz-box-shadow: 0 0 10px #777;
        -webkit-box-shadow: 0 0 10px #777;
        box-shadow: 0 0 10px #777;
      }
      #slide-how .slides .first {
        background: #fff;
        position: absolute;
        top: 20%;
        left: 20%;
        z-index: 1;
      }
      #slide-how .slides .second {
        position: relative;
        background: #fff;
        z-index: 0;
      }

      /* Two-column layout */
      .left-column {
        color: #777;
        width: 20%;
        height: 92%;
        float: left;
      }
        .left-column h2:last-of-type, .left-column h3:last-child {
          color: #000;
        }
      .right-column {
        width: 75%;
        float: right;
        padding-top: 1em;
      }
    </style>
    <script type="text/javascript"
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>

  </head>
  <body>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js"></script>
    <script src="/linalg/refreeze/js/springy.js"></script>
    <script src="/linalg/refreeze/js/springyui.js"></script>
    <script>
        
    </script>
    <textarea id="source">
name: inverse
layout: true
class: center, middle, inverse

---

# Linear Algebra in Python

## Olav Vahtras

KTH

---

layout: false

### Linear Algebra in Python: NumPy

* Libraries provided by ``numpy`` provide computational speeds close to compiled languages
* Generally written in C
* From a user perspective they are imported as any python module
* http://www.numpy.org

---

### Creating arrays

* one- and two-dimensional

```
&gt;&gt;&gt; import numpy
&gt;&gt;&gt; = numpy.zeros(3)
&gt;&gt;&gt; print type(a), a
&lt;type &#39;numpy.ndarray&#39;&gt; [ 0.  0.  0.]
&gt;&gt;&gt; b = numpy.zeros((3, 3))
&gt;&gt;&gt; print b
[[ 0.  0.  0.]
 [ 0.  0.  0.]
 [ 0.  0.  0.]]

```

---

### Copying arrays

```
    &gt;&gt;&gt; x = numpy.zeros(2)
    &gt;&gt;&gt; y = x
    &gt;&gt;&gt; x[0] = 1; print x, y
    [ 1.  0.] [ 1.  0.]

```
    
Note that assignment (like lists) here is by reference

```
    &gt;&gt;&gt; print x is y
    True

```

Numpy array copy method

```
    &gt;&gt;&gt; y = x.copy()
    &gt;&gt;&gt; print x is y
    False

```

---

### Filling arrays

``linspace`` returns an array with sequence data

```
    &gt;&gt;&gt; print numpy.linspace(0,1,6)
    [ 0.   0.2  0.4  0.6  0.8  1. ]

```

``arange`` is a similar function
::
    &gt;&gt;&gt; print numpy.arange(0, 1, 0.2)
    [ 0.   0.2  0.4  0.6  0.8]

---

From list objects

```
    &gt;&gt;&gt; la=[1.,2.,3.]
    &gt;&gt;&gt; a=numpy.array(la)
    &gt;&gt;&gt; print a
    [ 1.  2.  3.]

```
```
    &gt;&gt;&gt; lb=[4., 5., 6.]
    &gt;&gt;&gt; ab=numpy.array([la,lb])
    &gt;&gt;&gt; print ab
    [[ 1.  2.  3.]
     [ 4.  5.  6.]]

```

---

Creating arrays from file data:

* Using `numpy.loadtxt`
* If you have a text file with only numerical data
* Arranged as a matrix: all rows have the same number of elements


```
    $ cat a.dat
    1 2 3
    4 5 6
```

```
    &gt;&gt;&gt; a = numpy.loadtxt(&#39;a.dat&#39;)
    &gt;&gt;&gt; print a
    [[ 1.  2.  3.]
     [ 4.  5.  6.]]

```


### Reshaping

by changing the shape attribute


```
    print ab.shape
    (2, 3)
    ab.shape = (6,)
    print ab
    [ 1.  2.  3.  4.  5.  6.]
```
---
with the reshape method
```

    &gt;&gt;&gt; ba = ab.reshape((3, 2))
    &gt;&gt;&gt; print ba
    [[ 1.  2.]
     [ 3.  4.]
     [ 5.  6.]]

```

### Note

* ab and ba are different objects but represent different views  of the same data

```
    &gt;&gt;&gt; ab[0] = 0
    &gt;&gt;&gt; print ab 
    [ 0.  2.  3.  4.  5.  6.]
    &gt;&gt;&gt; print ba 
    [[ 0.  2.]
     [ 3.  4.]
     [ 5.  6.]]

```

### Element order

* multi-dimensional arrays follow C convention (row elements are close in memory)
* many transformational routines support a Fortran option

```
    &gt;&gt;&gt; ba = ab.reshape((3, 2), order=&#39;Fortran&#39;)
    &gt;&gt;&gt; print ba
    [[ 0.  4.]
     [ 2.  5.]
     [ 3.  6.]]

```

### Array indexing

like lists

* ``a[2:4]`` is an array slice with elements ``a[2]`` and ``a[3]``
* ``a[n:m]`` has size ``m-n``
* ``a[-1]`` is the last element of ``a``
* ``a[:]`` are all elements of ``a``


### Looping over elements

```
    &gt;&gt;&gt; r, c = ba.shape
    &gt;&gt;&gt; for i in range(r):
    ...    row = &#34;&#34;
    ...    for j in range(c):
    ...        row += &#34;%10.3f&#34; % ba[i, j]
    ...    print row
     0.000     4.000
     2.000     5.000
     3.000     6.000

```

---

alternative

```
    &gt;&gt;&gt; for r in ba:
    &gt;&gt;&gt;     row = &#34;&#34;
    &gt;&gt;&gt;     for e in r:
    &gt;&gt;&gt;         row += &#34;%10.3f&#34; % e
    &gt;&gt;&gt;     print row

     0.000     4.000
     2.000     5.000
     3.000     6.000

```
---
* The ``ravel`` methods returns a one-dim array

```
    &gt;&gt;&gt; for e in ba.ravel():
    ...    print e
    0.0
    4.0
    2.0
    5.0
    3.0
    6.0

```
    
---

* ``ndenumerate`` returns indices as well

```
    &gt;&gt;&gt; for ind, val in numpy.ndenumerate(ba):
    ...    print ind, val 
    (0, 0) 0.0
    (0, 1) 4.0
    (1, 0) 2.0
    (1, 1) 5.0
    (2, 0) 3.0
    (2, 1) 6.0

```



### Matrix operations

```
    &gt;&gt;&gt; import numpy, time
    &gt;&gt;&gt; n=256
    &gt;&gt;&gt; a=numpy.ones((n,n))
    &gt;&gt;&gt; b=numpy.ones((n,n))
    &gt;&gt;&gt; c=numpy.zeros((n,n))
    &gt;&gt;&gt; t1=time.clock()
    &gt;&gt;&gt; for i in range(n):
    ...    for j in range(n):
    ...        for k in range(n):
    ...            c[i,j]+=a[i,k]*b[k,j]
    &gt;&gt;&gt; t2=time.clock()
    &gt;&gt;&gt; print &#34;Loop timing&#34;,t2-t1
    Loop timing 77.38

```



### with `numpy.dot`

```
    &gt;&gt;&gt; import numpy, time
    &gt;&gt;&gt; n=256
    &gt;&gt;&gt; a=numpy.ones((n,n))
    &gt;&gt;&gt; b=numpy.ones((n,n))
    &gt;&gt;&gt; t1=time.clock()
    &gt;&gt;&gt; c=numpy.dot(a,b)
    &gt;&gt;&gt; t2=time.clock()
    &gt;&gt;&gt; print &#34;dot timing&#34;,t2-t1
    dot timing 0.05

```

### The Fortran version

```fortran
    INTEGER, PARAMETER :: N = 256
    REAL*8, DIMENSION(N,N) :: A, B, C
    ! Timing
    INTEGER :: T1, T2, RATE
    ! Initialize
    A = 1.0
    B = 1.0
    !
    CALL SYSTEM_CLOCK(COUNT_RATE=RATE)
    CALL SYSTEM_CLOCK(COUNT=T1)
    C = MATMUL(A, B)
    CALL SYSTEM_CLOCK(COUNT=T2)
    PRINT &#39;(A, F6.2)&#39;, &#39;MATMUL timing&#39;,  DBLE(T2-T1)/RATE
    END
```

### Conclusion

* Provided that numpy has been install properly (difficult) and linked with optimized libraries, basic linear algebra work as fast in python as in Fortran (or C/C++)

### More vector operations

* Scalar multiplication ``a*2`` 
* Scalar addition ``a + 2``
* Power (elementwise) ``a**2``

Note that for objects of ``ndarray`` type, multiplication means elementwise multplication and not matrix multiplication


### Vectorized elementary functions

```
    &gt;&gt;&gt; v = numpy.arange(0, 1, .2)
    &gt;&gt;&gt; print v
    [ 0.   0.2  0.4  0.6  0.8]
    &gt;&gt;&gt; print numpy.cos(v)
    [ 1.          0.98006658  0.92106099  0.82533561  0.69670671]
    &gt;&gt;&gt; print numpy.sqrt(v)
    [ 0.          0.4472136   0.63245553  0.77459667  0.89442719]
    &gt;&gt;&gt; print numpy.log(v)
    ./linalg.py:98: RuntimeWarning: divide by zero encountered in log
      print numpy.log(v)
    [       -inf -1.60943791 -0.91629073 -0.51082562 -0.22314355]

```

### Matrix-like objects

A special class that behave like matrices, ``numpy.matrix``

```
    &gt;&gt;&gt; m = numpy.matrix((1, 2, 3))
    &gt;&gt;&gt; print m
    [[1 2 3]]
    &gt;&gt;&gt; print m.T
    [[1]
     [2]
     [3]]

```
---

``*`` means matrix multiplication 

```
    &gt;&gt;&gt; print m.T*m
    [[1 2 3]
     [2 4 6]
     [3 6 9]]
    &gt;&gt;&gt; print m*m.T
    [[14]]

```

### Vectorized functions

* Any scalar function f can be vectorized
```
    vf = numpy.vectorize(f)

```

* Not always fast 

### Linear algebra

* Solve :math:`Ax = b`

```
    x = numpy.linalg.solve(A, b)

```

* Determinant

```
    x = numpy.linalg.det(A)

```

---
* Inverse :math:`A^{-1}`

```
    x = numpy.linalg.inverse(A)

```
    
*  Eigenvalues :math:`Ax = x\lambda`

```
    x, l = numpy.linalg.eig(A)

```
    </textarea>

    <script src="/linalg/refreeze/js/remark-latest.min.js" type="text/javascript"></script>
    <script type="text/javascript">
      var hljs = remark.highlighter.engine;
    </script>
    <script src="/linalg/refreeze/js/high.js" type="text/javascript"></script>
    <script type="text/javascript">
      var slideshow = remark.create({
          highlightStyle: 'sunburst',
          highlightLanguage: 'remark'
        }) ;
    </script>
  </body>
</html>